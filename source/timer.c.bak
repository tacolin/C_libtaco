#include "timer.h"
#include "task.h"
#include "lock.h"
#include "sema.h"

#include <string.h>

////////////////////////////////////////////////////////////////////////////////

#define TIMER_GUARD_CODE (0x5566)

////////////////////////////////////////////////////////////////////////////////

static int _system_init_flag = 0;

static tList _running_list;
static tLock _running_lock;

static tList _expired_list;
static tLock _expired_lock;

static tTask _tick_task;
static tTask _expire_task;

static tSem _expired_list_sem;

////////////////////////////////////////////////////////////////////////////////

static int _msToTick(int ms)
{
    return ms;
//    return (((ms) & 0xFFFF) * (HZ) / 1000 + ((ms) >> 16) * (0x10000 * (HZ) / 1000));
}

static void _cleanRunningTimer(void* arg)
{
    tTimer *timer = (tTimer*)arg;

    if (timer == NULL) return;

    timer->timeout    = 0;
    timer->expired_fn = NULL;
    timer->arg        = 0;
    timer->tick       = 0;
    timer->state      = TIMER_STOPPED;
    return;
}

static void _cleanExpiredTimer(void* arg)
{
    if (arg) free(arg);

    return;
}

static void _timerTickFunc(void* task, void *arg)
{
    tTimer *curr_timer;
    tTimer *next_timer;
    tTimer *expired_timer;
    tListStatus ret;

    long oldclock = (long)clock();
    timer_msleep(1);
    dprint("diff = %ld", (long)clock() - oldclock);

    lock_enter(&_running_lock);
    curr_timer = list_head(&_running_list);
    if (curr_timer)
    {
        curr_timer->tick--;

        do
        {
            if ( curr_timer->tick > 0 )
            {
                break;
            }

            next_timer = list_next(&_running_list, curr_timer);
            ret = list_remove(&_running_list, curr_timer);
            if (ret != LIST_OK)
            {
                derror("remove timer(%s) from running list failed", curr_timer->name);
                break;
            }

            curr_timer->state = TIMER_STOPPED;

            expired_timer = calloc(sizeof(tTimer), 1);
            if (expired_timer)
            {
                *expired_timer = *curr_timer;

                lock_enter(&_expired_lock);
                ret = list_append(&_expired_list, expired_timer);
                lock_exit(&_expired_lock);

                if ( ret != LIST_OK )
                {
                    derror("remove timer(%s) from expired list failed", expired_timer->name);
                    free(expired_timer);
                    break;
                }

                sema_inc(&_expired_list_sem);
            }
            else
            {
                derror("calloc failed");
                break;
            }

            curr_timer = next_timer;

        }while(curr_timer);
    }

    lock_exit(&_running_lock);

    return;
}

static void _timerExipredFunc(void* task, void* arg)
{
    tTimer *timer;
    tListStatus ret;

    sema_dec(&_expired_list_sem);

    lock_enter(&_expired_lock);
    timer = list_head(&_expired_list);
    ret   = list_remove(&_expired_list, timer);
    lock_exit(&_expired_lock);

    if (ret != LIST_OK)
    {
        derror("remove expired list node failed");
        return;
    }

    timer->expired_fn(timer->arg);
    free(timer);
    return;
}

tTimerStatus timer_init(tTimer *timer, char* name, int timeout, tTimerExpiredFn expired_fn, void* arg)
{
    int tick;

    check_if(_system_init_flag == 0, return TIMER_ERROR, "timer system is not initilized");
    check_if(timer == NULL, return TIMER_ERROR, "timer is null");
    // check_if((timer->guard_code == TIMER_GUARD_CODE) && (timer->state == TIMER_RUNNING),
    //          return TIMER_ERROR, "timer(%s) is running", timer->name);

    if (name)
    {
        snprintf(timer->name, TIMER_NAME_SIZE, "%s", name);
    }

    timer->timeout    = timeout;
    timer->expired_fn = expired_fn;
    timer->arg        = arg;
    tick              = _msToTick(timer->timeout);
    timer->tick       = (tick==0)? 1 : tick;
    timer->state      = TIMER_STOPPED;
    timer->guard_code = TIMER_GUARD_CODE;

    return TIMER_OK;
}

tTimerStatus timer_uninit(tTimer* timer)
{
    check_if(_system_init_flag == 0, return TIMER_ERROR, "timer system is not initilized");
    check_if(timer == NULL, return TIMER_ERROR, "timer is null");

    check_if((timer->guard_code == TIMER_GUARD_CODE)
             && (timer->state == TIMER_RUNNING),
             return TIMER_ERROR, "timer(%s) is still running", timer->name);

    memset(timer, 0, sizeof(tTimer));
    return TIMER_OK;
}

tTimerStatus timer_start(tTimer *timer)
{
    check_if(_system_init_flag == 0, return TIMER_ERROR, "timer system is not initilized");

    check_if(timer == NULL, return TIMER_ERROR, "timer is null");

    check_if(timer->guard_code != TIMER_GUARD_CODE, return TIMER_ERROR,
             "this timer(%s) is not initialized, can not be started",
             timer->name);

    check_if(timer->tick == 0, return TIMER_ERROR,
             "timer(%s) tick is 0, can not be started", timer->name);

    check_if(timer->state == TIMER_RUNNING, return TIMER_ERROR,
             "timer(%s) is running, can not be started again",
             timer->name);

    tTimer *target_obj;
    tListStatus status;
    int tick = 0;

    lock_enter(&_running_lock);

    /*
    *  _running_list:
    *     +-----+    +-----+
    *     |  6  | => |+1(6)|
    *     +-----+    +-----+
    *                    |
    *                    v
    *  +-----+-----+-----+-----+-----+-----+
    *  |  5  |+0(5)|+0(5)|+2(7)|+0(7)|+1(8)| ...
    *  +-----+-----+-----+-----+-----+-----+
    *                       |
    *                       v
    *                    +-----+
    *                    |+1(7)|
    *                    +-----+
    */

    target_obj = list_head(&_running_list);
    if (target_obj)
    {
        tick = 0;
        do
        {
            tick += target_obj->tick;

            if ( timer->tick < tick )
            {
                break;
            }

            target_obj = list_next(&_running_list, target_obj);

        }while(target_obj);

        if (target_obj)
        {
            timer->tick = target_obj->tick - (tick - timer->tick);
            target_obj->tick = target_obj->tick - timer->tick;
            status = list_insertTo(&_running_list, target_obj, timer);
        }
        else
        {
            /* timer with the greatest tick */
            timer->tick = timer->tick - tick;
            status = list_append(&_running_list, timer);
        }

        if ( status != LIST_OK )
        {
            derror("insert/append timer to running list failed");
            lock_exit(&_running_lock);
            return TIMER_ERROR;
        }
    }
    else
    {
        /* there is no any timer in _running_list */
        status = list_insert(&_running_list, timer);
        if ( status != LIST_OK )
        {
            derror("insert/append timer to running list failed");
            lock_exit(&_running_lock);
            return TIMER_ERROR;
        }
    }

    timer->state = TIMER_RUNNING;

    lock_exit(&_running_lock);

    return TIMER_OK;
}

tTimerStatus timer_stop(tTimer *timer)
{
    check_if(_system_init_flag == 0, return TIMER_ERROR, "timer system is not initilized");
    check_if(timer == NULL, return TIMER_ERROR, "timer is null");
    check_if(timer->guard_code != TIMER_GUARD_CODE, return TIMER_ERROR,
             "this timer(%s) is not initialized, can not be started",
             timer->name);
    check_if(timer->state == TIMER_STOPPED, return TIMER_ERROR,
             "timer(%s) is stopped, can not be started again", timer->name);

    tTimer *next_timer;
    tTimer *prev_timer;
    int tick;

    lock_enter(&_running_lock);

    next_timer = list_next(&_running_list, timer);
    if (next_timer)
    {
        next_timer->tick += timer->tick;
    }

    /* restore the tick of timer */
    tick = timer->tick;
    prev_timer = list_prev(&_running_list, timer);
    while (prev_timer)
    {
        tick += prev_timer->tick;
        prev_timer = list_prev(&_running_list, prev_timer);
    }

    if (LIST_OK != list_remove(&_running_list, timer))
    {
        derror("remove timer(%s) from running list failed", timer->name);
        lock_exit(&_running_lock);
        return TIMER_ERROR;
    }

    timer->tick  = tick;
    timer->state = TIMER_STOPPED;

    lock_exit(&_running_lock);
    return OK;
}

void timer_msleep(int ms)
{
    struct timeval timeout;

    timeout.tv_sec = ms / 1000;
    timeout.tv_usec = (ms % 1000) * 1000;

    while ( select(0, 0, 0, 0, &timeout) < 0)
    {
        /* do nothing */
    }
}

tTimerStatus timer_system_init(void)
{
    if (_system_init_flag == 0)
    {
        list_init(&_running_list, "timer running list", _cleanRunningTimer);
        lock_init(&_running_lock);

        list_init(&_expired_list, "timer expired list", _cleanExpiredTimer);
        lock_init(&_expired_lock);

        task_init(&_tick_task, "timer tick", _timerTickFunc,
                  NULL, TASK_HIGH, TASK_NON_PREEMPTIVE);

        task_init(&_expire_task, "timer expired", _timerExipredFunc,
                  NULL, TASK_HIGH, TASK_NON_PREEMPTIVE);

        sema_init(&_expired_list_sem, 0);

        task_start(&_tick_task);
        task_start(&_expire_task);

        _system_init_flag = 1;
        return TIMER_OK;
    }
    else
    {
        derror("timer system has already been initialized!");
    }

    return TIMER_ERROR;
}

tTimerStatus timer_system_uninit(void)
{
    if ( _system_init_flag == 1 )
    {
        int num;

        task_stop(&_tick_task);
        task_stop(&_expire_task);

        num = list_length(&_running_list);
        if ( num > 0 )
        {
            derror("there are %d running timers at un-initialization", num);
        }
        list_clean(&_running_list);

        num = list_length(&_expired_list);
        if ( num > 0 )
        {
            derror("there are %d expired timers at un-initialization", num);
        }
        list_clean(&_expired_list);

        sema_uninit(&_expired_list_sem);

        lock_uninit(&_running_lock);
        lock_uninit(&_expired_lock);

        _system_init_flag = 0;

        return TIMER_OK;
    }
    else
    {
        derror("timer system is not initialized!");
    }

    return TIMER_ERROR;
}
